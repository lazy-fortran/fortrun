# AST Architecture for *Lazy Fortran* Compiler Frontend

## Current Implementation Status ✅

**COMPLETED**: The AST-based compiler frontend is **production-ready** with a complete 4-phase architecture.

### Architecture Overview

The frontend implements a clean, modular pipeline following modern compiler design principles:

```
Source Code (.lf, .f90)
        ↓
┌──────────────────────────────────────┐
│        Production Frontend           │
│                                      │
│  ┌────────────┐                     │
│  │   Lexer    │ → Tokens (JSON)     │
│  └────────────┘                     │
│         ↓                           │
│  ┌────────────┐                     │
│  │   Parser   │ → AST (JSON)        │
│  └────────────┘                     │
│         ↓                           │
│  ┌────────────────────┐             │
│  │ Semantic Analyzer  │ → Typed AST │
│  │ (Hindley-Milner)   │    (JSON)   │
│  └────────────────────┘             │
│         ↓                           │
│  ┌────────────────────┐             │
│  │  Code Generator    │ → F90 Code  │
│  └────────────────────┘             │
│                                      │
│  Debug: --debug-tokens --debug-ast   │
│         --debug-semantic --debug-    │
│         codegen                      │
└──────────────────────────────────────┘
        ↓
   Standard Fortran 90 Output
```

## Core Components

### 1. Lexer (`src/frontend/lexer/lexer_core.f90`)
- **Dialect-agnostic tokenization**
- 24 Fortran keywords, 8 token types
- JSON serialization for debug/testing
- Handles operators, numbers, identifiers, strings

### 2. Parser (`src/frontend/parser/parser_core.f90`)
- **Dialect-agnostic recursive descent parser**
- Comprehensive AST node generation
- Handles expressions, statements, functions, control flow
- Proper multi-line construct parsing (functions, do loops, if blocks)

### 3. AST Core (`src/frontend/ast_core.f90`)
- **Complete AST node hierarchy**
- **Generational Arena memory management** (expert-level design)
- Visitor pattern support
- Source location preservation with integer handle system

### 4. Semantic Analyzer (`src/frontend/semantic/semantic_analyzer.f90`)
- **Hindley-Milner type inference with Algorithm W**
- Full unification and substitution system
- Type schemes and generalization
- Occurs check and type safety

### 5. Code Generator (`src/frontend/codegen/codegen_core.f90`)
- **Standard Fortran 90 output generation**
- Modern defaults (implicit none, real(8))
- Proper program structure generation
- Intent(in) parameter enhancement

## Architecture Principles

### 1. Dialect Agnostic Core
- Core modules (`lexer_core`, `parser_core`, `semantic_analyzer`, `codegen_core`, `ast_core`) contain **NO** dialect-specific features
- All extensions go in `src/frontend/standard/` subdirectories
- Clean separation between standards and implementation

### 2. Complete AST Pipeline
- **MANDATORY**: All processing through proper AST nodes
- **FORBIDDEN**: Direct token-to-code shortcuts
- **REQUIRED**: Full semantic analysis for all constructs
- **ENFORCED**: No string manipulation bypassing AST

### 3. JSON Workflow
Each phase supports JSON input/output for debugging and testing:
- `--debug-tokens` → tokens.json
- `--debug-ast` → ast.json  
- `--debug-semantic` → semantic.json
- `--debug-codegen` → codegen.json

### 4. Type System
- **Hindley-Milner Algorithm W** for automatic inference
- **Type variables** with proper occurs checking
- **Substitution system** with composition
- **Polymorphic wrapper pattern** for array safety

## Key Design Decisions

### 1. Generational Arena Architecture
**Expert Classification**: **Generational Arena** / **Regional Allocator**

**Design Rationale**: Our AST implementation requires both bulk construction performance AND selective modification capabilities for:
- Semantic analysis augmenting existing nodes with type information
- Multi-standard transformations (Fortran 95/2003/2008+ compatibility)
- Advanced language features (multiple dispatch, metaprogramming)
- Compiler optimization passes

**Implementation**: Hybrid approach combining arena benefits with modification flexibility
```fortran
type :: ast_arena_t
    type(ast_entry_t), allocatable :: entries(:)
    integer :: size = 0
    integer :: capacity = 0
    integer :: chunk_size = 1024           ! Chunk-based growth
    integer :: initial_capacity = 256      ! Starting size
end type
```

**Key Features**:
- **Chunk-based growth**: 1024-entry increments prevent O(n) copy operations
- **Ordered deallocation**: `pop()` and `clear()` maintain memory safety
- **Integer handles**: Avoid pointer invalidation during arena expansion
- **Automatic shrinking**: Memory optimization when usage < 25%

**Expert Assessment**: Standard practice in modern compilers (Rust, Swift, LLVM) - optimized for compiler workloads with predictable growth and selective manipulation requirements.

### 2. Handle-Based References
**Pattern**: Integer indices instead of pointers for memory safety during arena growth.

**Implementation**:
```fortran
! Safe access pattern
function get_node(arena, index) result(node_ptr)
    type(ast_arena_t), intent(in) :: arena
    integer, intent(in) :: index
    class(ast_node), pointer :: node_ptr

    node_ptr => arena%entries(index)%node
end function
```

### 3. Multi-line Construct Parsing
**Challenge**: Fortran constructs span multiple lines (functions, do loops, if blocks).

**Solution**: Parser state machine with proper lookahead:
- Detect program unit boundaries
- Parse complete constructs as single units
- Maintain proper AST hierarchy

### 4. Future-Ready Architecture
**Anticipates ROADMAP.md Requirements**:
- **Phase 9**: Full type inference with AST augmentation
- **Multi-Standard Support**: AST transformations between Fortran versions
- **Advanced Features**: Multiple dispatch requiring node duplication/modification
- **Compiler Integration**: Optimization passes before IR generation

**Why Pure Arena Would Fail**: Cannot modify AST structure after construction, breaking semantic analysis and optimization requirements.

## Testing Architecture

### Comprehensive Test Coverage
```
test/frontend/
├── lexer/test_frontend_lexer_*.f90      # Lexer component tests
├── parser/test_frontend_parser_*.f90     # Parser component tests  
├── semantic/test_frontend_semantic_*.f90 # Semantic analysis tests
├── codegen/test_frontend_codegen_*.f90   # Code generation tests
└── test_frontend_integration.f90        # Full pipeline tests
```

### Test Categories
- **Unit tests**: Individual component testing
- **API tests**: Interface validation
- **Integration tests**: Full pipeline validation
- **JSON workflow tests**: Debug output validation

## *Lowercase Fortran* Extensions

### Dialect-Specific Features (`src/frontend/standard/lowercase_fortran/`)
- **Implicit program wrapping**: No `program`/`end program` needed
- **Automatic type inference**: Variables declared through assignment
- **Modern defaults**: `implicit none`, `real(8)`, `intent(in)`
- **Automatic contains insertion**: For functions/subroutines

### Semantic Analysis Extensions
- **Program vs Module decision**: Deferred to semantic analyzer
- **Type inference enhancement**: Beyond standard Fortran
- **Parameter intent enhancement**: Automatic `intent(in)` addition

## Future Architecture Extensions

### 1. Multi-Standard Support
- **Fortran 2003**: OOP, parameterized types
- **Fortran 2008**: Coarrays, submodules  
- **Fortran 2018**: New features
- **Extensible backends**: Pluggable code generation

### 2. Advanced Type System
- **Multiple dispatch**: Julia-like generic programming
- **Type classes**: Haskell-inspired abstractions
- **Bidirectional checking**: Explicit + inferred types
- **Gradual typing**: Mixed annotation support

### 3. Alternative Backends
- **LLVM IR**: Direct compilation to optimized code
- **C transpilation**: Portable output
- **Native code**: Direct machine code generation
- **Source maps**: Debug information preservation

## Implementation Quality

### Memory Management
- **Generational Arena**: Expert-level design combining performance with flexibility
- **Chunk-based allocation**: 1024-entry growth prevents O(n) copy operations
- **Ordered deallocation**: Memory safety through reverse-order cleanup
- **Handle-based access**: Integer indices prevent pointer invalidation

### Error Handling
- **Graceful degradation**: Fallback to direct output for unimplemented features
- **Clear diagnostics**: Meaningful error messages with source locations
- **Recovery strategies**: Continue parsing after errors when possible

### Performance
- **Efficient parsing**: Single-pass with minimal backtracking
- **Compact AST**: Memory-efficient node representation
- **Fast compilation**: Minimal overhead over traditional approaches

## Success Metrics

### ✅ Completed
- **Complete 4-phase architecture**: All phases implemented and working
- **Hindley-Milner type inference**: Algorithm W with unification
- **Comprehensive testing**: 30+ test files with wildcard discovery
- **JSON workflow**: Debug output for all phases
- **Standard compliance**: Valid Fortran 90 output generation
- **Generational Arena**: Production-ready memory management architecture

### 🎯 Current Focus
- **FPM Registry integration**: Official module database
- **Enhanced language features**: Advanced *lazy fortran* syntax
- **Performance optimization**: Faster compilation times
- **Extended type system**: More sophisticated inference

### 🔮 Future Goals
- **LLVM backend**: Direct IR generation
- **Multiple dispatch**: Advanced type system features
- **Full Fortran 2003+**: Modern Fortran feature support
- **Interactive development**: REPL and enhanced tooling

## Architecture Documentation

### Core Principles
1. **Modular design**: Clean interfaces between components
2. **Extensibility**: Easy addition of new language features  
3. **Standard compliance**: Respect Fortran language semantics
4. **Type safety**: Sound type inference with error detection
5. **Performance**: Efficient compilation without sacrificing correctness

This architecture provides a solid foundation for advanced language features while maintaining compatibility with standard Fortran and enabling future extensions like multiple dispatch, advanced type systems, and alternative compilation backends.
